//@version=6
strategy("AMT Volumetric Strategy v6 — Stable Edition (Fixed idx)", 
     overlay = true, 
     margin_long = 100, 
     margin_short = 100, 
     default_qty_type = strategy.percent_of_equity, 
     default_qty_value = 1)

// === INPUTS ===
bins          = input.int(30, "Profile bins per session", minval=10)
va_percent    = input.float(70.0, "Value Area %", minval=50.0, maxval=90.0) / 100.0
vol_sma_len   = input.int(20, "Volume SMA for phase detection")
atr_len       = input.int(14, "ATR Length")
risk_mult     = input.float(1.0, "Stop Distance (ATR×)")
take_mult     = input.float(1.5, "Target Distance (ATR×)")
session_reset = input.session("0000-2359", "Session Reset (Exchange hours)")

// === SESSION RESET ===
new_session = ta.change(time("D")) != 0

// === SESSION RANGE TRACKING ===
var float s_high = na
var float s_low  = na
if new_session or na(s_high)
    s_high := high
    s_low  := low
else
    s_high := math.max(s_high, high)
    s_low  := math.min(s_low, low)
session_range = math.max(s_high - s_low, syminfo.mintick)

// === INITIALIZE VOLUME BINS (SAFE) ===
var vol_bins = array.new_float()
if new_session or array.size(vol_bins) == 0
    array.clear(vol_bins)
    for _ = 0 to bins - 1
        array.push(vol_bins, 0.0)

// === SAFE INDEX VARIABLES ===
var int va_min_idx = 0
var int va_max_idx = 0
var int poc_idx = 0
var float poc_vol = 0.0
var float total_vol = 0.0

// === ASSIGN BAR VOLUME TO BIN ===
if session_range > 0 and array.size(vol_bins) == bins
    bin_idx_raw = (close - s_low) / session_range * (bins - 1)
    bin_idx_calc = int(math.floor(bin_idx_raw))
    // manual clamp
    bin_idx = bin_idx_calc < 0 ? 0 : (bin_idx_calc > (bins - 1) ? (bins - 1) : bin_idx_calc)
    array.set(vol_bins, bin_idx, array.get(vol_bins, bin_idx) + volume)

// === CALCULATE POC / VALUE AREA ===
if array.size(vol_bins) == bins
    poc_idx := 0
    poc_vol := 0.0
    total_vol := 0.0

    for i = 0 to bins - 1
        v = array.get(vol_bins, i)
        total_vol += v
        if v > poc_vol
            poc_vol := v
            poc_idx := i

    va_target = total_vol * va_percent
    va_cum = poc_vol
    va_min_idx := poc_idx
    va_max_idx := poc_idx
    left = poc_idx - 1
    right = poc_idx + 1

    while va_cum < va_target and (left >= 0 or right <= bins - 1)
        left_vol = left >= 0 ? array.get(vol_bins, left) : -1.0
        right_vol = right <= bins - 1 ? array.get(vol_bins, right) : -1.0
        if left_vol > right_vol
            va_cum += math.max(left_vol, 0)
            va_min_idx := left
            left -= 1
        else
            va_cum += math.max(right_vol, 0)
            va_max_idx := right
            right += 1

// === MAP BIN INDEX → PRICE LEVEL ===
bin_width = session_range / bins
price_of(idx) => s_low + (idx + 0.5) * bin_width
poc_price = price_of(poc_idx)
val_price = price_of(va_min_idx)
vah_price = price_of(va_max_idx)

// === PHASE DETECTION ===
vol_sma = ta.sma(volume, vol_sma_len)
is_in_value = close >= val_price and close <= vah_price
balance_phase = is_in_value and (volume < vol_sma)
inefficiency_phase = (close > vah_price or close < val_price) and (volume > vol_sma)

// === ORDER FLOW PROXY (CVD) ===
up_vol = close > open ? volume : 0.0
dn_vol = close < open ? volume : 0.0
cvd = ta.cum(up_vol - dn_vol)

// === RISK MANAGEMENT ===
atr = ta.atr(atr_len)
stop_dist = atr * risk_mult
take_dist = atr * take_mult

// === PRE-CALCULATE CROSS / RISE / FALL ===
cross_over_val = ta.crossover(close, val_price)
cross_under_vah = ta.crossunder(close, vah_price)
cvd_rising = ta.rising(cvd, 3)
cvd_falling = ta.falling(cvd, 3)

// === ENTRY CONDITIONS ===
long_balance  = balance_phase and cross_over_val
short_balance = balance_phase and cross_under_vah
long_trend    = inefficiency_phase and close > vah_price and cvd_rising
short_trend   = inefficiency_phase and close < val_price and cvd_falling

// === EXECUTIONS ===
if long_balance
    strategy.entry("Long_BAL", strategy.long)
    strategy.exit("Exit_LB", "Long_BAL", stop = close - stop_dist, limit = close + take_dist)

if short_balance
    strategy.entry("Short_BAL", strategy.short)
    strategy.exit("Exit_SB", "Short_BAL", stop = close + stop_dist, limit = close - take_dist)

if long_trend
    strategy.entry("Long_TRND", strategy.long)
    strategy.exit("Exit_LT", "Long_TRND", stop = close - stop_dist, limit = close + take_dist)

if short_trend
    strategy.entry("Short_TRND", strategy.short)
    strategy.exit("Exit_ST", "Short_TRND", stop = close + stop_dist, limit = close - take_dist)

// === VISUALS ===
plot(poc_price, "POC", color=color.orange, linewidth=2)
plot(val_price, "VAL", color=color.new(color.green, 0))
plot(vah_price, "VAH", color=color.new(color.red, 0))
bgcolor(balance_phase ? color.new(color.teal, 88) : inefficiency_phase ? color.new(color.red, 88) : na)

// === ALERTS ===
alertcondition(long_balance or long_trend, "AMT Buy Signal", "Auction Market Buy Setup")
alertcondition(short_balance or short_trend, "AMT Sell Signal", "Auction Market Sell Setup")

Make it live strategy so it can execute trade automatically and show on the graph of MT5 take it and tune the parameters automatically after each iteration to get maximum profitable trades